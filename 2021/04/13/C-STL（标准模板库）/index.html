

<!DOCTYPE html>
<html lang="UTF-8" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>C++STL（标准模板库） - lybbor&#39;s blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="Standard Template Library是一...">
  <meta name="author" content="lybbor">
  <link rel="icon" href="/images/icons/favicon-16x16.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-16x16.ico" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/favicon-16x16.ico" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/favicon-16x16.ico" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-16x16.ico">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '/images/theme/loading.gif'
      },
      donate: {
        enable: false,
        alipay: '',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '/images/theme/welcome-image.jpg',
          api: ''
        },
        motto: {
          default: '嗝儿',
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: '/images/2.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        model: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.2.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
    </div>
    <div class="center">C++STL（标准模板库）</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  

<nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p><p>lybbor's blog</p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/article/IMG_0508(20210412-235109).JPG" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">C++STL（标准模板库）</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>April 13, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>8639</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        </p>
<h1 id="1-STL简介"><a href="#1-STL简介" class="headerlink" title="1.STL简介"></a>1.STL简介</h1><p>STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。</p>
<p>STL的一个重要特点是<strong>数据结构和算法的分离</strong>。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组；</p>
<p>STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效；</p>
<p>从逻辑层次来看，在STL中体现了泛型化程序设计的思想，引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代子（iterator）等。与OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术；</p>
<p>从实现层次看，整个STL是以一种类型参数化的方式实现的，这种方式基于一个在早先C++标准中没有出现的语言特性–模板（template）。</p>
<h1 id="2-六大组件"><a href="#2-六大组件" class="headerlink" title="2.六大组件"></a>2.六大组件</h1><ul>
<li>容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；</li>
<li>迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；</li>
<li>算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；</li>
<li>仿函数（Functor）</li>
<li>适配器（Adaptor）</li>
<li>分配器（allocator）<h2 id="2-1-容器"><a href="#2-1-容器" class="headerlink" title="2.1 容器"></a>2.1 容器</h2><img    class="lazyload" data-original="https://img-blog.csdnimg.cn/20190507220214982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NjU1MzU3,size_16,color_FFFFFF,t_70" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="    title="容器类"><span class="image-caption">容器类</span><br><a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference" title="参考文档">参考文档</a></li>
</ul>
<h3 id="2-1-1-顺序容器（第一类容器）"><a href="#2-1-1-顺序容器（第一类容器）" class="headerlink" title="2.1.1 顺序容器（第一类容器）"></a>2.1.1 顺序容器（第一类容器）</h3><h4 id="2-1-1-1-矢量：vector"><a href="#2-1-1-1-矢量：vector" class="headerlink" title="2.1.1.1 矢量：vector"></a>2.1.1.1 矢量：vector</h4><blockquote>
<p>表示可以改变大小的数组的序列容器。就像数组一样，向量对它们的元素使用连续的存储位置，这意味着它们的元素也可以使用指向其元素的常规指针上的偏移量来访问，并且效率与数组相同。但是与数组不同，它们的大小可以动态更改，其存储由容器自动处理。</p>
</blockquote>
<p><strong>主要使用的成员函数:</strong><br><strong>Iterators(迭代器):</strong><br>begin() 返回迭代器到开始<br>end() 返回迭代器到结束</p>
<p><strong>容量：</strong><br>size() 返回大小<br>empty() 测试矢量是否为空<br>reverse() 矢量翻转</p>
<p><strong>元素访问：</strong><br>operator[] 访问元素<br>at() 访问元素<br>front() 访问第一个元素<br>back() 访问最后一个元素</p>
<p><strong>修改操作：</strong><br>push_back() 在末尾添加元素<br>pop_back() 删除最后一个元素<br>insert() 插入元素<br>erase() 擦除元素[可以清除一段，也可以值清除某一点]<br>swap() 交换内容<br>clear() 清除内容</p>
<h4 id="2-1-1-2-双端队列：deque"><a href="#2-1-1-2-双端队列：deque" class="headerlink" title="2.1.1.2 双端队列：deque"></a>2.1.1.2 双端队列：deque</h4><blockquote>
<p>双端队列是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。</p>
</blockquote>
<p><strong>迭代：</strong><br>begin() 返回迭代器到开始<br>end() 返回迭代器到结束</p>
<p><strong>容量：</strong><br>size() 返回大小<br>empty() 检测是否为空</p>
<p><strong>访问元素：</strong><br>operator[] 访问元素<br>at() 访问元素<br>front() 访问第一个元素<br>back() 访问最后一个元素</p>
<p><strong>修改元素：</strong><br>push_back() 在末尾插入元素<br>push_front() 在首部插入元素<br>pop_back() 删掉末尾的元素<br>pop_front() 删掉首部的元素<br>insert() 插入元素<br>erase() 擦除元素<br>swap() 交换<br>clean() 清除</p>
<h4 id="2-1-1-3-列表：list"><a href="#2-1-1-3-列表：list" class="headerlink" title="2.1.1.3 列表：list"></a>2.1.1.3 列表：list</h4><blockquote>
<p>列表是序列容器，允许在序列中的任何位置进行恒定时间的插入和擦除操作，并在两个方向上进行迭代。</p>
</blockquote>
<p><strong>迭代：</strong><br>begin() 返回迭代器到开始<br>end() 返回迭代器到末尾</p>
<p><strong>容量：</strong><br>empty() 检测是否为空<br>size() 返回大小<br>max_size() 返回最大大小</p>
<p><strong>元素访问：</strong><br>front() 访问首部元素<br>back() 访问尾部元素</p>
<p><strong>修改：</strong><br>assign() 初始化<br>emplace_front() 构造和在首部插入元素C++11引入<br>push_front() 在首部插入元素<br>pop_front() 删掉首部元素<br>emplace_back() 构造和在尾部插入元素C++11引入<br>push_back() 在末尾插入元素<br>pop_back() 在尾部插入元素<br>emplace() 构造并自选位置插入C++11引入<br>insert() 在指定位置的元素之前插入新元素来扩展容器。<br>erase() 擦除一个或一段<br>swap() 交换<br>clear() 清除</p>
<p><strong>操作：</strong><br>splice() 将元素从一个列表转移到另一个列表<br>remove() 删掉具有特定值的某元素<br>remove_if() 删除满足条件的元素<br>unique() 去重<br>merge() 合并列表<br>reverse() 倒置</p>
<h3 id="2-1-2-关联容器（第一类容器）"><a href="#2-1-2-关联容器（第一类容器）" class="headerlink" title="2.1.2 关联容器（第一类容器）"></a>2.1.2 关联容器（第一类容器）</h3><h4 id="2-1-2-1-集合：set"><a href="#2-1-2-1-集合：set" class="headerlink" title="2.1.2.1 集合：set"></a>2.1.2.1 集合：set</h4><blockquote>
<p>集合是按照特定顺序存储唯一元素的容器。</p>
</blockquote>
<p><strong>迭代器：</strong><br>begin() 返回迭代器到首部<br>end() 返回迭代器到尾部</p>
<p><strong>容量：</strong><br>empty() 检测集合是否为空<br>size() 返回容器大小<br>max_size() 返回最大的容器大小</p>
<p><strong>修改：</strong><br>insert() 插入元素<br>erase() 擦除元素<br>swap() 交换元素<br>clear() 清除</p>
<p><strong>观察员：</strong><br>key_comp() 返回比较对象,默认less，所以而这比较是小于的话返回true<br>value_comp() 返回比较对象,默认less，所以而这比较是小于的话返回true</p>
<p><strong>操作：</strong><br>find() 获取元素的迭代器<br>count() 计算具有特定值的元素<br>lower_bound() 返回迭代器到上限<br>upper_bound() 返回迭代器到下线<br>equal_range() 获取相同元素的范围，是两个迭代器</p>
<h4 id="2-1-2-2-映射：map"><a href="#2-1-2-2-映射：map" class="headerlink" title="2.1.2.2 映射：map"></a>2.1.2.2 映射：map</h4><blockquote>
<p>映射是关联容器，用于存储按特定顺序由键值和映射值的组合形成的元素。</p>
</blockquote>
<p><strong>迭代器：</strong><br>begin() 返回迭代器到首部<br>end() 返回迭代器到尾部</p>
<p><strong>容量：</strong><br>empty() 检测是否为空<br>size() 返回容器大小<br>max_size() 返回最大大小</p>
<p><strong>元素访问：</strong><br>operator[] 访问元素<br>at() 访问元素 c++11引入</p>
<p><strong>修改：</strong><br>insert() 插入元素<br>erase() 擦除元素<br>swap() 交换元素<br>clear() 清除元素<br>emplace() 构造并插入元素<br>emplace_hint() 选位置插入元素</p>
<p><strong>观察员：</strong><br>key_comp()<br>value_comp()</p>
<p><strong>操作：</strong><br>find()<br>count()<br>lower_bound()<br>upper_bound()<br>equal_bound()</p>
<h4 id="2-1-2-3-多重集合：multiset"><a href="#2-1-2-3-多重集合：multiset" class="headerlink" title="2.1.2.3 多重集合：multiset"></a>2.1.2.3 多重集合：multiset</h4><blockquote>
<p><strong>与set区别：</strong><br><strong>multiset:</strong></p>
</blockquote>
<ol>
<li>可以插入完全相同的两条记录。</li>
<li>会提高数据插入的速度。</li>
</ol>
<blockquote>
<p><strong>set:</strong></p>
</blockquote>
<ol>
<li>不可以插入完全相同的两条记录</li>
<li>保证记录的唯一性</li>
<li>由于需要查重处理，会降低数据插入的速度</li>
<li>可以作为一种去重的方法</li>
</ol>
<p><strong>迭代器：</strong><br>begin()<br>end()</p>
<p><strong>容量：</strong><br>empty()<br>size()<br>max_size()</p>
<p><strong>修改：</strong><br>insert()<br>erase()<br>swap()<br>clear()</p>
<p><strong>观察者：</strong><br>find()<br>count()<br>lower_bound()<br>upper_bound()<br>equal_range()</p>
<h4 id="2-1-2-4-多重映射：multimap"><a href="#2-1-2-4-多重映射：multimap" class="headerlink" title="2.1.2.4 多重映射：multimap"></a>2.1.2.4 多重映射：multimap</h4><blockquote>
<p>multimap中的key可以重复,没有重载operator[ ]功能,对于重复的元素，查找的时候也是返回中序遍历的第一个元素。</p>
</blockquote>
<p><strong>迭代器：</strong><br>begin()<br>end()</p>
<p><strong>容器：</strong><br>empty()<br>size()<br>max_size()</p>
<p><strong>修改：</strong><br>insert()<br>erase()<br>swap()<br>clear()<br>emplace() C++11引入<br>emplace_hint() C++11引入</p>
<p><strong>观察者：</strong><br>key_comp()<br>value_comp()</p>
<p><strong>操作：</strong><br>find()<br>count()<br>lower_bound()<br>upper_bound()<br>equal_range()</p>
<h4 id="2-1-2-5-无序映射：unordered-map"><a href="#2-1-2-5-无序映射：unordered-map" class="headerlink" title="2.1.2.5 无序映射：unordered_map"></a>2.1.2.5 无序映射：unordered_map</h4><p><strong>和hash_map、map的区别：</strong><br>1.和map的区别</p>
<blockquote>
<p>内部实现机理不同，map的内部结构是R-B-tree来实现的，所以保证了一个稳定的动态操作时间，查询、插入、删除都是O（logn），最坏和平均都是。<br>hash_map是哈希表，哈希表的查询时间虽然是O（1），但是并不是unordered_map查询时间一定比map短，因为实际情况中还要考虑到数据量，而且unordered_map的hash函数的构造速度也没那么快，所以不能一概而论，应该具体情况具体分析。</p>
</blockquote>
<p>2.和hash_map的区别</p>
<blockquote>
<p>这两个的内部结构都是采用哈希表来实现。<br>unordered_map在C++11的时候被引入标准库了，而hash_map没有，所以建议还是使用unordered_map比较好。</p>
</blockquote>
<h4 id="2-1-2-6-无序集：unordered-set"><a href="#2-1-2-6-无序集：unordered-set" class="headerlink" title="2.1.2.6 无序集：unordered_set"></a>2.1.2.6 无序集：unordered_set</h4><p><strong>在以下情况下使用unordered_set：</strong></p>
<ol>
<li>我们需要保留一组不同的元素，并且不需要排序。</li>
<li>我们需要单元素访问，即无遍历。</li>
</ol>
<p><strong>何时使用set：</strong></p>
<ol>
<li>我们需要有序的数据。</li>
<li>我们将不得不打印/访问数据（按排序顺序）。</li>
<li>我们需要元素的前任/后继。</li>
<li>由于set是有序的，因此我们可以在set元素上使用binary_search()，lower_bound()和upper_bound()之类的函数。这些函数不能在unordered_set()上使用。</li>
</ol>
<h3 id="2-1-3-容器适配器"><a href="#2-1-3-容器适配器" class="headerlink" title="2.1.3 容器适配器"></a>2.1.3 容器适配器</h3><blockquote>
<p>容器适配器是用基本容器实现的一些新容器,这些容器可以用于描述更高级的数据结构。<del>（说简单点就是跟接口转换器差不多的功能）</del><br>栈，队列，优先队列。</p>
</blockquote>
<h4 id="2-1-3-1-栈：stack"><a href="#2-1-3-1-栈：stack" class="headerlink" title="2.1.3.1 栈：stack"></a>2.1.3.1 栈：stack</h4><blockquote>
<p><strong>LIFO</strong>,堆栈是一种容器适配器，专门设计用于在LIFO上下文（后进先出）中操作，在LIFO上下文中，仅从容器的一端插入和提取元素。</p>
</blockquote>
<p><strong>成员函数：</strong><br>empty()<br>size()<br>top()<br>push()<br>emplace() C++11引入<br>pop()<br>swap()</p>
<p><strong>非成员函数重载：</strong><br>swap(stack) C++11引入</p>
<h4 id="2-1-3-2-队列：queue"><a href="#2-1-3-2-队列：queue" class="headerlink" title="2.1.3.2 队列：queue"></a>2.1.3.2 队列：queue</h4><p><strong>成员函数：</strong><br>empty()<br>size()<br>front()<br>back()<br>push()<br>emplace()<br>pop()<br>swap()</p>
<p><strong>非成员函数重载：</strong><br>swap(queue)</p>
<h4 id="2-1-3-3-优先队列：priority-queue"><a href="#2-1-3-3-优先队列：priority-queue" class="headerlink" title="2.1.3.3 优先队列：priority_queue"></a>2.1.3.3 优先队列：priority_queue</h4><blockquote>
<p>优先级队列是一种容器适配器，经过专门设计，以使其按照某些严格的弱排序标准，其第一个元素始终是其中包含的最大元素。<br>此上下文类似于<strong>堆</strong>，可以在任何时候插入元素，并且只能检索最大堆元素（优先级队列顶部的元素）</p>
</blockquote>
<p><strong>成员函数：</strong><br>empty()<br>size()<br>top()<br>push()<br>emplace() C++11<br>pop()<br>swap() C++11</p>
<p><strong>非成员函数重载：</strong><br>swap(queue) </p>
<h2 id="2-2-Iterator-STL迭代器"><a href="#2-2-Iterator-STL迭代器" class="headerlink" title="2.2 Iterator(STL迭代器)"></a>2.2 Iterator(STL迭代器)</h2><p>Iterator（迭代器）模式又称Cursor（游标）模式。用于提供一种方法顺序访问一个聚合对象中各个元素, 而又<strong>不需暴露该对象的内部表示</strong>。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们<strong>可以在不知道对象内部表示的情况下</strong>，按照一定顺序（由iterator提供的方法）<strong>访问聚合对象中的各个元素</strong>。<br>类似智能指针，重载了很多指针的成员函数，是指针的提升。</p>
<h3 id="2-2-1-迭代器的作用"><a href="#2-2-1-迭代器的作用" class="headerlink" title="2.2.1 迭代器的作用"></a>2.2.1 迭代器的作用</h3><p>能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator.</p>
<h2 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3 算法"></a>2.3 算法</h2><blockquote>
<p>我愿称之为神！！！！</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linuxAndMcu/p/10264339.html" title="参考博客">参考博客</a></p>
<h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h3><blockquote>
<p>STL算法部分主要由头文件 <algorithm>,<numeric>,<functional> 组成。要使用 STL中的算法函数必须包含头文件 <algorithm>，对于数值算法须包含 <numeric>，<functional> 中则定义了一些模板类，用来声明函数对象。</p>
</blockquote>
<h3 id="2-3-2-常用算法①：查找算法"><a href="#2-3-2-常用算法①：查找算法" class="headerlink" title="2.3.2 常用算法①：查找算法"></a>2.3.2 常用算法①：查找算法</h3><blockquote>
<p>查找算法共13个，包含在<algorithm>头文件中，用来提供元素排序策略。<br>这里只列出一部分算法：</p>
</blockquote>
<ul>
<li><strong>count:</strong>利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。</li>
<li><strong>count_if:</strong>利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。</li>
<li><strong>binary_search:</strong>在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。</li>
<li><strong>equal_range:</strong>功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。</li>
<li><strong>find:</strong>利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回指向该元素的Iterator。</li>
<li><strong>search:</strong>给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。</li>
<li><strong>search_n:</strong>在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。</li>
</ul>
<h3 id="2-3-3-常用算法②：排序和通用算法"><a href="#2-3-3-常用算法②：排序和通用算法" class="headerlink" title="2.3.3 常用算法②：排序和通用算法"></a>2.3.3 常用算法②：排序和通用算法</h3><blockquote>
<p>排序算法共14个，包含在<algorithm>头文件中，用来判断容器中是否包含某个值。</p>
</blockquote>
<ul>
<li><strong>merge:</strong>合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。</li>
<li><strong>random_shuffle:</strong>对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。</li>
<li><strong>nth_element:</strong>将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。</li>
<li><strong>reverse:</strong>将指定范围内元素重新反序排序。</li>
<li><strong>sort:</strong>以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。</li>
<li><strong>stable_sort:</strong>与sort类似，不过保留相等元素之间的顺序关系。</li>
</ul>
<h3 id="2-3-4-常用算法③：删除和替换算法"><a href="#2-3-4-常用算法③：删除和替换算法" class="headerlink" title="2.3.4 常用算法③：删除和替换算法"></a>2.3.4 常用算法③：删除和替换算法</h3><blockquote>
<p>删除和替换算法共15个，包含在<numeric>头文件中。</p>
</blockquote>
<ul>
<li><strong>copy:</strong>复制序列。</li>
<li><strong>copy_backward:</strong>与copy相同，不过元素是以相反顺序被拷贝。</li>
<li><strong>remove:</strong>删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。</li>
<li><strong>remove_copy:</strong>将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。</li>
<li><strong>remove_if:</strong>删除指定范围内输入操作结果为true的所有元素。</li>
<li><strong>remove_copy_if:</strong>将所有不匹配元素拷贝到一个指定容器。</li>
<li><strong>replace:</strong>将指定范围内所有等于vold的元素都用vnew代替。</li>
<li><strong>replace_copy:</strong>与replace类似，不过将结果写入另一个容器。</li>
<li><strong>replace_if:</strong>将指定范围内所有操作结果为true的元素用新值代替。</li>
<li><strong>replace_copy_if:</strong>与replace_if，不过将结果写入另一个容器。</li>
<li><strong>swap:</strong>交换存储在两个对象中的值。</li>
<li><strong>swap_range:</strong> 将指定范围内的元素与另一个序列元素值进行交换。</li>
<li><strong>unique:</strong> 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。</li>
<li><strong>unique_copy:</strong>与unique类似，不过把结果输出到另一个容器。</li>
</ul>
<h3 id="2-3-5-常用算法④：排列组合算法"><a href="#2-3-5-常用算法④：排列组合算法" class="headerlink" title="2.3.5 常用算法④：排列组合算法"></a>2.3.5 常用算法④：排列组合算法</h3><blockquote>
<p>排列组合算法共2个，包含在<algorithm>头文件中，用来提供计算给定集合按一定顺序的所有可能排列组合。</p>
</blockquote>
<ul>
<li><strong>next_permutation:</strong>取出当前范围内的排列，并重新排序为下一个字典序排列。重载版本使用自定义的比较操作。</li>
<li><strong>prev_permutation:</strong>取出指定范围内的序列并将它重新排序为上一个字典序排列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。</li>
</ul>
<h3 id="2-3-6-常用算法⑤：数值算法"><a href="#2-3-6-常用算法⑤：数值算法" class="headerlink" title="2.3.6 常用算法⑤：数值算法"></a>2.3.6 常用算法⑤：数值算法</h3><blockquote>
<p>数值算法共4个，包含在<numeric>头文件中。</p>
</blockquote>
<ul>
<li><strong>accumulate:</strong>iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。</li>
<li><strong>partial_sum:</strong>创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。</li>
<li><strong>inner_product:</strong>对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。</li>
<li><strong>adjacent_difference:</strong>创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。</li>
</ul>
<h3 id="2-3-7-常用算法⑥：生成和异变算法"><a href="#2-3-7-常用算法⑥：生成和异变算法" class="headerlink" title="2.3.7 常用算法⑥：生成和异变算法"></a>2.3.7 常用算法⑥：生成和异变算法</h3><blockquote>
<p>生成和异变算法共6个，包含在<algorithm>头文件中。</p>
</blockquote>
<ul>
<li><strong>fill:</strong>将输入值赋给标志范围内的所有元素。</li>
<li><strong>fill_n:</strong>将输入值赋给first到first+n范围内的所有元素。</li>
<li><strong>for_each:</strong>用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。</li>
<li><strong>generate:</strong>连续调用输入的函数来填充指定的范围。</li>
<li><strong>generate_n:</strong>与generate函数类似，填充从指定iterator开始的n个元素。</li>
<li><strong>transform:</strong>将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。</li>
</ul>
<h3 id="2-3-8-常用算法⑦：关系算法"><a href="#2-3-8-常用算法⑦：关系算法" class="headerlink" title="2.3.8 常用算法⑦：关系算法"></a>2.3.8 常用算法⑦：关系算法</h3><blockquote>
<p>关系算法共8个，包含在<algorithm>头文件中。</p>
</blockquote>
<ul>
<li><strong>equal:</strong>如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。</li>
<li><strong>includes:</strong>判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。</li>
<li><strong>max:</strong> 返回两个元素中较大一个。重载版本使用自定义比较操作。</li>
<li><strong>min:</strong>返回两个元素中较小一个。重载版本使用自定义比较操作。</li>
<li><strong>max_element:</strong>返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。</li>
<li><strong>min_element:</strong>返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。</li>
<li><strong>mismatch:</strong> 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。</li>
</ul>
<h3 id="2-3-9-常用算法⑧：集合算法"><a href="#2-3-9-常用算法⑧：集合算法" class="headerlink" title="2.3.9 常用算法⑧：集合算法"></a>2.3.9 常用算法⑧：集合算法</h3><blockquote>
<p>集合算法共4个，包含在<algorithm>头文件中。</p>
</blockquote>
<ul>
<li><strong>set_union:</strong>构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。</li>
<li><strong>set_intersection:</strong>构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。</li>
<li><strong>set_difference:</strong> 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。</li>
<li><strong>set_symmetric_difference:</strong>构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。</li>
</ul>
<h3 id="2-3-10-常用算法⑨：堆算法"><a href="#2-3-10-常用算法⑨：堆算法" class="headerlink" title="2.3.10 常用算法⑨：堆算法"></a>2.3.10 常用算法⑨：堆算法</h3><blockquote>
<p>集合算法共4个，包含在<algorithm>头文件中。</p>
</blockquote>
<ul>
<li><strong>make_heap:</strong>把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。</li>
<li><strong>pop_heap:</strong>并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。</li>
<li><strong>push_heap:</strong>假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。</li>
</ul>
<h2 id="2-4-仿函数"><a href="#2-4-仿函数" class="headerlink" title="2.4 仿函数"></a>2.4 仿函数</h2><h3 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h3><h3 id="2-4-2-STL中的仿函数"><a href="#2-4-2-STL中的仿函数" class="headerlink" title="2.4.2 STL中的仿函数"></a>2.4.2 STL中的仿函数</h3>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>lybbor</li>
    <!-- <li><strong>本文链接：</strong><a href="http://example.com/2021/04/13/C-STL%EF%BC%88%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%89/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;04&#x2F;13&#x2F;C-STL%EF%BC%88%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%89&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;04&#x2F;13&#x2F;C-STL%EF%BC%88%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%89&#x2F;index.html</a></li> -->
    <li><strong>版权声明：</strong>本博客所有文章均采用 
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/" rel="tag">STL标准模板库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul> 

        
  <nav class="nav">
    <a href="/2021/04/15/%E5%AD%97%E5%85%B8%E6%A0%91/"><i class="iconfont iconleft"></i>字典树</a>
    <a href="/2021/04/12/%E6%AC%A7%E6%8B%89%E7%B4%A0%E6%95%B0%E7%AD%9B/">欧拉筛<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-STL%E7%AE%80%E4%BB%8B"><span class="toc-text">1.STL简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">2.六大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%AE%B9%E5%99%A8"><span class="toc-text">2.1 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%EF%BC%88%E7%AC%AC%E4%B8%80%E7%B1%BB%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="toc-text">2.1.1 顺序容器（第一类容器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%EF%BC%88%E7%AC%AC%E4%B8%80%E7%B1%BB%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="toc-text">2.1.2 关联容器（第一类容器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">2.1.3 容器适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Iterator-STL%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">2.2 Iterator(STL迭代器)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2.2.1 迭代器的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%AE%97%E6%B3%95"><span class="toc-text">2.3 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">2.3.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%91%A0%EF%BC%9A%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.2 常用算法①：查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%91%A1%EF%BC%9A%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%9A%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.3 常用算法②：排序和通用算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%91%A2%EF%BC%9A%E5%88%A0%E9%99%A4%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.4 常用算法③：删除和替换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%91%A3%EF%BC%9A%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.5 常用算法④：排列组合算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-6-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%91%A4%EF%BC%9A%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.6 常用算法⑤：数值算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-7-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%91%A5%EF%BC%9A%E7%94%9F%E6%88%90%E5%92%8C%E5%BC%82%E5%8F%98%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.7 常用算法⑥：生成和异变算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-8-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%91%A6%EF%BC%9A%E5%85%B3%E7%B3%BB%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.8 常用算法⑦：关系算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-9-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%91%A7%EF%BC%9A%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.9 常用算法⑧：集合算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-10-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%91%A8%EF%BC%9A%E5%A0%86%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.10 常用算法⑨：堆算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">2.4 仿函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">2.4.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-STL%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">2.4.2 STL中的仿函数</span></a></li></ol></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=1156202084 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://github.com/lybbor "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:rz1156202084@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p><p>lybbor's blog</p>
    </div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>





  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>