

<!DOCTYPE html>
<html lang="UTF-8" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Leetcode刷题记录 - lybbor&#39;s blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="坚持刷题！思维upup！ 
每日一题2021.04.0...">
  <meta name="author" content="lybbor">
  <link rel="icon" href="/images/icons/favicon-16x16.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-16x16.ico" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/favicon-16x16.ico" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/favicon-16x16.ico" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-16x16.ico">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '/images/theme/loading.gif'
      },
      donate: {
        enable: false,
        alipay: '',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '/images/theme/welcome-image.jpg',
          api: ''
        },
        motto: {
          default: '嗝儿',
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: '/images/2.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        model: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.2.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
    </div>
    <div class="center">Leetcode刷题记录</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  

<nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p><p>lybbor's blog</p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/article/mmexport1607774723491.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Leetcode刷题记录</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>April 07, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>17640</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        </p>
<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><h2 id="2021-04-07"><a href="#2021-04-07" class="headerlink" title="2021.04.07"></a>2021.04.07</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" title="点击进入题目">点击进入题目</a><br><strong>思路：</strong></p>
<blockquote>
<p>1.暴力for。<br>2.二分查找。</p>
</blockquote>
<p><strong>解析：</strong><br><strong>2.二分查找</strong><br>思路：<br>1.左中右值相等又不等于target,缩小区间：l++,r–；</p>
<p>2.左区间有序:<br>(1)target在有序的区间内，范围变为：[l,mid-1]<br>(2)target不在这段有序的区间中，范围变为：[mid+1,r]</p>
<p>3.右区间有序:<br>(1)target在这段有序区间内，范围变为：[mid-1,r];<br>(2)target不再这段有序区间内，范围变为：[l,mid+1];</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=nums.size();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]==target)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>; <span class="hljs-keyword">if</span>(nums[mid]==target||nums[l]==target||nums[r]==target)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(nums[l]==nums[mid]&amp;&amp;nums[r]==nums[mid])&#123;<br>                l++;<br>                r--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[l]&lt;=nums[mid])&#123;<br>                <span class="hljs-keyword">if</span>(nums[l]&lt;target&amp;&amp;nums[mid]&gt;target)<br>                    r=mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span> <br>                    l=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(nums[r]&gt;target&amp;&amp;nums[mid]&lt;target)<br>                    l=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>1.暴力for：(不是重点)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=nums.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="2021-04-08"><a href="#2021-04-08" class="headerlink" title="2021.04.08"></a>2021.04.08</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">点击进入题目</a><br><strong>思路：</strong></p>
<blockquote>
<p>1.二分<br>2.暴力for</p>
</blockquote>
<p><strong>解析：</strong><br>1.二分<br>(1)一旦nums[l]&gt;=nums[mid]说明更小的一定在[l，mid-1]内<br>(2)要判断一下边界nums[l],nums[r]是不是更小的，这是用于处理有序的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=nums.size();<br>        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> min=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-keyword">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;min)min=nums[mid];<br>            <span class="hljs-keyword">if</span>(nums[l]&lt;min)min=nums[l];<br>            <span class="hljs-keyword">if</span>(nums[r]&lt;min)min=nums[r];<br>            <span class="hljs-keyword">if</span>(nums[l]&gt;=nums[mid])&#123;<br>                r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                l=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>2.暴力（懒得贴了）</p>
<h2 id="2020-04-09"><a href="#2020-04-09" class="headerlink" title="2020.04.09"></a>2020.04.09</h2><h2 id="2020-04-10-263-丑数"><a href="#2020-04-10-263-丑数" class="headerlink" title="2020.04.10 263.丑数"></a>2020.04.10 263.丑数</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ugly-number/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a><br><strong>思路：</strong><br>简单暴力。</p>
<p><strong>解析：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUgly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>            n=n/<span class="hljs-number">2</span>;&#125;<br>        <span class="hljs-keyword">while</span>(n%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>            n=n/<span class="hljs-number">3</span>;&#125;<br>        <span class="hljs-keyword">while</span>(n%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>            n=n/<span class="hljs-number">5</span>;&#125;<br>        <span class="hljs-keyword">if</span>(n!=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="2020-04-11-264-丑数Ⅱ"><a href="#2020-04-11-264-丑数Ⅱ" class="headerlink" title="2020.04.11 264.丑数Ⅱ"></a>2020.04.11 264.丑数Ⅱ</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ugly-number-ii/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>1.DP，三指针<br>2.暴力打表</p>
<p><strong>解析：</strong><br>1.DP，三指针<br>三个指针：ptr1,ptr2,ptr3<br>ptr1负责*2操作，ptr2负责*3操作，ptr3负责*5操作<br>找到每次的最小值，找到了就让指针向前跑一格<br>（手动模拟一遍就懂了）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans[n+<span class="hljs-number">2</span>];<br>        ans[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ptr1=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ptr2=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ptr3=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">int</span> minn=min(ans[ptr1]*<span class="hljs-number">2</span>,min(ans[ptr2]*<span class="hljs-number">3</span>,ans[ptr3]*<span class="hljs-number">5</span>));<br>            ans[i]=minn;<br>            <span class="hljs-keyword">if</span>(ans[ptr1]*<span class="hljs-number">2</span>==minn)<br>                ptr1++;<br>            <span class="hljs-keyword">if</span>(ans[ptr2]*<span class="hljs-number">3</span>==minn)<span class="hljs-comment">//不能用else if 因为其他的如果相同了 也该往前跑一步！！</span><br>                ptr2++;<br>            <span class="hljs-keyword">if</span>(ans[ptr3]*<span class="hljs-number">5</span>==minn)<br>                ptr3++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>2.打表<br>适合竞赛的时候用，这里主要是DP，不贴打表做法了。</p>
<h2 id="2020-04-12-179-最大数"><a href="#2020-04-12-179-最大数" class="headerlink" title="2020.04.12 179.最大数"></a>2020.04.12 179.最大数</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-number/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>修改sort方法，将合适的位置放好，再用to_string函数拼接成答案返回</p>
<p><strong>解析：</strong><br>1.没有用到C++精髓的cmp：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> sx=<span class="hljs-number">10</span>;<span class="hljs-comment">//不开long要爆int</span><br>        <span class="hljs-keyword">long</span> sy=<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>(a&gt;=sx)<br>            sx*=<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>(b&gt;=sy)<br>            sy*=<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">return</span> sx*b+a&lt;sy*a+b; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">largestNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        sort(nums.begin(),nums.end(),cmp);<br>        <span class="hljs-built_in">string</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)<br>            ans+=to_string(num);<br>        <span class="hljs-keyword">if</span>(ans[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>; <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>2.用到了C++精髓的cmp：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-built_in">string</span> x=to_string(a);<br>        <span class="hljs-built_in">string</span> y=to_string(b);<br>        <span class="hljs-keyword">return</span> x+y&gt;y+x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">largestNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        sort(nums.begin(),nums.end(),cmp);<br>        <span class="hljs-built_in">string</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)<br>            ans+=to_string(num);<br>        <span class="hljs-keyword">if</span>(ans[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>; <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2020-04-13-783-二叉搜索树节点最小距离"><a href="#2020-04-13-783-二叉搜索树节点最小距离" class="headerlink" title="2020.04.13 783.二叉搜索树节点最小距离"></a>2020.04.13 783.二叉搜索树节点最小距离</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>1.BFS(非递归)，找每个节点，用vector存起来然后sort一下，再遍历一下两两之差（代码又臭又长）<br>(感觉需要写个stl的博客了，太不熟练)<br>2.官方题解①：中序遍历(递归)<br>3.官方题解②：莫里斯中序遍历</p>
<p><strong>解析：</strong><br>1.BFS：<br>queue实现遍历每个节点，vector来存放每个节点的value，所有节点遍历完之后，对vector排个序，循环看看哪两个数的差最小就是答案了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDiffInBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode *&gt; roots;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span> &gt;ans;<br>        roots.push(root);<br>        ans.push_back(root-&gt;val);<br>        <span class="hljs-keyword">int</span> submin=<span class="hljs-number">900000</span>;<br>        <span class="hljs-keyword">while</span>(!roots.empty())&#123;<br>                TreeNode * tmproot;<br>                tmproot=roots.front();<br>                roots.pop();<br>                <span class="hljs-keyword">if</span>(tmproot-&gt;left)&#123;<br>                   roots.push(tmproot-&gt;left);<br>                   ans.push_back(tmproot-&gt;left-&gt;val);<br>               &#125;<br>                <span class="hljs-keyword">if</span>(tmproot-&gt;right)&#123;<br>                    roots.push(tmproot-&gt;right);<br>                    ans.push_back(tmproot-&gt;right-&gt;val);<br>                &#125;<br>        &#125;<br>        sort(ans.begin(),ans.end());<br>        <span class="hljs-keyword">int</span> n=ans.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(submin&gt;ans[i]-ans[i<span class="hljs-number">-1</span>])&#123;<br>                submin=ans[i]-ans[i<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> submin;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>2.DFS(递归，中序遍历)：<br>全局定义最小值，然后每次递归的时候更新最小值，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> minn=<span class="hljs-number">900000</span>;<br>    TreeNode* pre;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDiffInBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> minn;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span>;<br>        dfs(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">nullptr</span>)&#123;<br>            minn=min(minn,<span class="hljs-built_in">abs</span>(root-&gt;val-pre-&gt;val));<br>        &#125;<br>        pre=root;<br>        dfs(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="2021-04-14-208-实现Trie-前缀树"><a href="#2021-04-14-208-实现Trie-前缀树" class="headerlink" title="2021.04.14 208.实现Trie(前缀树)"></a>2021.04.14 208.实现Trie(前缀树)</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>1.无敌的STL法：string + unordered_set<br>2.乖乖建树</p>
<p><strong>题解：</strong><br>1.STL法</p>
<ul>
<li>学前缀树就知道了，可以用hash表存放串，找的时候直接通过函数找只要O(1)，这里直接用unordered_set来存放；</li>
<li>然后用string的find函数，可以找到字串在母串哪个位置，直接字串是不是第一位就Ok</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unordered_set</span> &lt;<span class="hljs-built_in">string</span> &gt; mode;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    Trie() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>&#123;<br>        mode.insert(word);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mode.find(word)!=mode.end())<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-built_in">string</span> prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s:mode)&#123;<br>            <span class="hljs-keyword">if</span>(s.find(prefix)==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>2.建树</p>
<h2 id="2021-04-15-213-打家劫舍Ⅱ"><a href="#2021-04-15-213-打家劫舍Ⅱ" class="headerlink" title="2021.04.15 213.打家劫舍Ⅱ"></a>2021.04.15 213.打家劫舍Ⅱ</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>头取或者尾取，那么我们就开两个数组，一个存取头之后的max，一个存取尾之后的max</p>
<p><strong>题解：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=nums.size();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">1</span>],nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> dp1[<span class="hljs-number">110</span>];<br>        dp1[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp1[<span class="hljs-number">1</span>]=nums[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> dp2[<span class="hljs-number">110</span>];<br>        dp2[n<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;<br>        dp2[n<span class="hljs-number">-2</span>]=nums[n<span class="hljs-number">-2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>            dp1[i]=max(dp1[i<span class="hljs-number">-1</span>],dp1[i<span class="hljs-number">-2</span>]+nums[i]);<br>            dp2[n-i<span class="hljs-number">-1</span>]=max(dp2[n-i],dp2[n-i+<span class="hljs-number">1</span>]+nums[n-i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max(dp1[n<span class="hljs-number">-1</span>],dp2[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2021-04-16-87-扰乱字符串-困难"><a href="#2021-04-16-87-扰乱字符串-困难" class="headerlink" title="2021.04.16 87.扰乱字符串(困难)"></a>2021.04.16 87.扰乱字符串(困难)</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/scramble-string/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<h2 id="2021-04-17-220-存在重复元素Ⅲ"><a href="#2021-04-17-220-存在重复元素Ⅲ" class="headerlink" title="2021.04.17 220.存在重复元素Ⅲ"></a>2021.04.17 220.存在重复元素Ⅲ</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate-iii/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>set、滑动窗口<br>运用set内部排序的机制，滑动窗口主要就是要准确利用合适的数据结构；窗口就是边界的处理，内部所需要的东西，需要通过不同的数据结构来实现。</p>
<p><strong>解析：</strong></p>
<ol>
<li>eptr从小到大循环</li>
<li>窗口大小(即set.size())必须小于等于k，一旦比k大，左边界移一步（即从set里删除当前的sptr）</li>
<li>通过lower_bound()来找比nums[right]-t更大的数，如果找到了 就是true</li>
<li>如果循环完都没有找到，返回false</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=nums.size();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>||n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">long</span> &gt;s1;<br>        <span class="hljs-keyword">int</span> sptr=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> eptr=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(eptr&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(eptr-sptr&gt;k)&#123;<br>                s1.erase(nums[sptr]);<br>                sptr++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s1.lower_bound((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> )nums[eptr]-t)!=s1.end()&amp;&amp;(*(s1.lower_bound((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)nums[eptr]-t))-nums[eptr]&lt;=t))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            s1.insert(nums[eptr]);<br>            eptr++;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


<h2 id="2021-04-18-26-删除有序数组中的重复项"><a href="#2021-04-18-26-删除有序数组中的重复项" class="headerlink" title="2021.04.18 26.删除有序数组中的重复项"></a>2021.04.18 26.删除有序数组中的重复项</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>简单题</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> n=nums.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==nums[i<span class="hljs-number">-1</span>])&#123;<br>                nums.erase(nums.begin()+i);<br>                i--;<br>                n--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2021-04-19-27-移除元素"><a href="#2021-04-19-27-移除元素" class="headerlink" title="2021.04.19 27.移除元素"></a>2021.04.19 27.移除元素</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-element/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>vector的erase函数，简单死了，代码都懒得放了。</p>
<hr>
<hr>
<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="58-左旋转字符串"><a href="#58-左旋转字符串" class="headerlink" title="58.左旋转字符串"></a>58.左旋转字符串</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" title="点击进入题目">点击进入题目</a></p>
<p><strong>思路：</strong><br>简单暴力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a=s.length();<br>        <span class="hljs-built_in">string</span> b=s;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;a-n;i++)&#123;<br>            s[i]=b[i+n];<br>        &#125;<br>        <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;i&lt;a;i++)&#123;<br>            s[i]=b[j++];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" title="点击进入题目">点击进入题目</a></p>
<p><strong>思路：</strong><br>左子节点和右子节点交换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode * tmp=root-&gt;left;<br>        root-&gt;left=mirrorTree(root-&gt;right);<br>        root-&gt;right=mirrorTree(tmp);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55.二叉树的深度"></a>55.二叉树的深度</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" title="点击进入题目">点击进入题目</a></p>
<p><strong>思路：</strong></p>
<blockquote>
<p>1.DFS<br>2.BFS</p>
</blockquote>
<p><strong>解析：</strong><br>1.DFS:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+max(maxDepth(root-&gt;left),maxDepth(root-&gt;right));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>2.BFS:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> depth=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode *&gt; Q;<br>        Q.push(root);<br>        <span class="hljs-keyword">while</span>(!Q.empty())&#123;<br>            <span class="hljs-keyword">int</span> n=Q.size();<br>            depth++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                TreeNode * tmp=Q.front();<br>                Q.pop();<br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)<br>                    Q.push(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)<br>                    Q.push(tmp-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="22-链表中倒数第K个节点"><a href="#22-链表中倒数第K个节点" class="headerlink" title="22.链表中倒数第K个节点"></a>22.链表中倒数第K个节点</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" title="点击进入题目">点击进入题目</a></p>
<p><strong>思路：</strong></p>
<blockquote>
<p>1.暴力得到链表长度，然后用n-k来得到倒数<br>2.双指针</p>
</blockquote>
<p><strong>解析：</strong><br>1.暴力跑</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>&amp;&amp; !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">int</span> n=<span class="hljs-number">1</span>;<br>        ListNode * t=head;<br>        <span class="hljs-keyword">while</span>(t&amp;&amp;t-&gt;next)&#123;<br>            n++;<br>            t=t-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(n-i==k)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> <br>                head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>2.双指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode* first=head;<br>        ListNode* later=head;<br>        <span class="hljs-keyword">while</span>(k--)&#123;<br>            first=first-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(first)&#123;<br>            later=later-&gt;next;<br>            first=first-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> later;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17.打印从1到最大的n位数"></a>17.打印从1到最大的n位数</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>暴力</p>
<p><strong>解析：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span> &gt;ans;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<br>        ans.push_back(i);<br>        <span class="hljs-keyword">while</span>(i++)&#123;<br>            <span class="hljs-keyword">int</span> num=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> tmp=i;<br>            <span class="hljs-keyword">while</span>(tmp/<span class="hljs-number">10</span>)&#123;<br>                num++;<br>                tmp/=<span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num&gt;n) <span class="hljs-keyword">break</span>;<br>            ans.push_back(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>注意边界，循环跑</p>
<p><strong>解析：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>         <span class="hljs-keyword">if</span>(matrix.size() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>].size()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right=matrix[<span class="hljs-number">0</span>].size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> top=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> bottom=matrix.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;=right;i++)&#123;<br>                ans.push_back(matrix[top][i]);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=top+<span class="hljs-number">1</span>;i&lt;=bottom;i++)&#123;<br>                ans.push_back(matrix[i][right]);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left&lt;right&amp;&amp;top&lt;bottom)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=right<span class="hljs-number">-1</span>;i&gt;=left;i--)&#123;<br>                    ans.push_back(matrix[bottom][i]);<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=bottom<span class="hljs-number">-1</span>;i&gt;top;i--)&#123;<br>                    ans.push_back(matrix[i][left]);<br>                &#125;<br>            &#125;<br>            right--;<br>            left++;<br>            bottom--;<br>            top++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>


<h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05.替换空格"></a>05.替换空格</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>知识点就是正确使用string，string直接拼接就完事，很简单</p>
<p><strong>解析：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-built_in">string</span> ans;<br>        <span class="hljs-keyword">int</span> n=s.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                ans+=s[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans+=<span class="hljs-string">&quot;%20&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="06-从头到尾打印链表"><a href="#06-从头到尾打印链表" class="headerlink" title="06.从头到尾打印链表"></a>06.从头到尾打印链表</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>很傻一道题，把链表的数用vector存下来，用个reverse函数翻转一下就ok。</p>
<p><strong>解析：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span> &gt;ans;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            ans.push_back(head-&gt;val);<br>            head=head-&gt;next;<br>        &#125;<br>        reverse(ans.begin(),ans.end());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="题库"><a href="#题库" class="headerlink" title="题库"></a>题库</h1><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>很easy，偷还是不偷两种选择<br>公式：dp[n]=max(dp[n-1],dp[n-1]+nums[i]);</p>
<p><strong>解析：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> dp[<span class="hljs-number">1010</span>];<br>        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">1</span>],nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;nums.size();i++)&#123;<br>            dp[i]=max(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.size()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


<h2 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/%22%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%A2%98%E7%9B%AE%22">点击进入题目</a></p>
<p><strong>思路：</strong><br>入门级滑动窗口。</p>
<p><strong>解析：</strong></p>
<ol>
<li>开个hashmap来存字母出现次数</li>
<li>左右指针中，右指针向右遍历</li>
<li>遍历过程中如果当前字母是之前出现过的，就找到之前出现的位置，把左值针指向找到的位置，缩小窗口<br>在循环中不断更新ans。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n=s.size();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; ss;<br>        <span class="hljs-keyword">int</span> sptr=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> eptr=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(eptr&lt;n)&#123;<br>            <span class="hljs-keyword">char</span> c1=s[eptr++];<br>            ss[c1]++;<br>            <span class="hljs-keyword">while</span>(ss[c1]&gt;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">char</span> c2=s[sptr];<br>                ss[c2]--;<br>                sptr++;<br>            &#125;<br>            ans=max(ans,eptr-sptr);<br>        &#125; <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>lybbor</li>
    <!-- <li><strong>本文链接：</strong><a href="http://example.com/2021/04/07/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;04&#x2F;07&#x2F;Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;04&#x2F;07&#x2F;Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95&#x2F;index.html</a></li> -->
    <li><strong>版权声明：</strong>本博客所有文章均采用 
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul> 

        
  <nav class="nav">
    <a href="/2021/04/12/%E6%AC%A7%E6%8B%89%E7%B4%A0%E6%95%B0%E7%AD%9B/"><i class="iconfont iconleft"></i>欧拉筛</a>
    <a href="/2021/03/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统笔记<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98"><span class="toc-text">每日一题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-04-07"><span class="toc-text">2021.04.07</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-04-08"><span class="toc-text">2021.04.08</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2020-04-09"><span class="toc-text">2020.04.09</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2020-04-10-263-%E4%B8%91%E6%95%B0"><span class="toc-text">2020.04.10 263.丑数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2020-04-11-264-%E4%B8%91%E6%95%B0%E2%85%A1"><span class="toc-text">2020.04.11 264.丑数Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2020-04-12-179-%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-text">2020.04.12 179.最大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2020-04-13-783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB"><span class="toc-text">2020.04.13 783.二叉搜索树节点最小距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-04-14-208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">2021.04.14 208.实现Trie(前缀树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-04-15-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A1"><span class="toc-text">2021.04.15 213.打家劫舍Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-04-16-87-%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%9B%B0%E9%9A%BE"><span class="toc-text">2021.04.16 87.扰乱字符串(困难)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-04-17-220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E2%85%A2"><span class="toc-text">2021.04.17 220.存在重复元素Ⅲ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-04-18-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">2021.04.18 26.删除有序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-04-19-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">2021.04.19 27.移除元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%91%E6%8C%87offer"><span class="toc-text">剑指offer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">58.左旋转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-text">27.二叉树的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-text">55.二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">22.链表中倒数第K个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0"><span class="toc-text">17.打印从1到最大的n位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-text">29.顺时针打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-text">05.替换空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="toc-text">06.从头到尾打印链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%98%E5%BA%93"><span class="toc-text">题库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198.打家劫舍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2"><span class="toc-text">3.无重复字符的最长字串</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=1156202084 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://github.com/lybbor "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:rz1156202084@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p><p>lybbor's blog</p>
    </div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>





  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>